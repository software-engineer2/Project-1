/*
Debamita Saha
SOLAR ID#: 112494564
debamita.saha@stonybrook.edu
Homework #5
Course: CSE 214
Recitation number: R04
TA's Name: James Finn
*/

package Homework5;

import java.io.*;
import java.util.Scanner;
import java.util.zip.DataFormatException;

/**
 * This is a class named StoryTree, which represents the primary
 * data structure for the Zork game. This class is a ternary
 * (3-child) tree of StoryTreeNodes, which are structured as a
 * continuous chain of decisions the user may make to reach the
 * end of the game (any leaf node).
 */
public class StoryTree {
    private static StoryTreeNode root;
    private StoryTreeNode cursor;
    private GameState state;

    /*
        This class is a ternary (3-child) tree of StoryTreeNodes
        End of the game is any leaf node.
        public static StoryTree readTree(String filename)

        Brief:
            Reads in a text file describing a StoryTree.
            See sample input for an example.
         */

    /**
     * Brief:
     * Default constructor for the StoryTree class.
     */
    public StoryTree() {
        cursor = root;
        root = new StoryTreeNode();
        root.setMessage("Hello, welcome to Zork!");
        root.setOption("root");
        root.setPosition("root");
    }

//    StoryTreeNode insertToLeft(StoryTreeNode currentNode,
//                               String position,
//                               String option, String message) {
//        StoryTreeNode newNode =
//        new StoryTreeNode(position, option, message);
//            while (currentNode != null) {
//                currentNode = currentNode.getLeftChild();
//            }
//            if (currentNode == null) {
//                currentNode.setLeftChild(newNode);
//            }
//            return newNode;
// }
//
//    StoryTreeNode insertToMiddle(StoryTreeNode currentNode,
//                               String position,
//                               String option, String message) {
//        StoryTreeNode newNode =
//        new StoryTreeNode(position, option, message);
//        if (currentNode != null && currentNode.getMiddleChild()
//        == null) {
//            currentNode.setMiddleChild(insertToMiddle
//            (newNode, position, option, message));
//        }
//        return newNode;
//    }
//
//    StoryTreeNode insertToRight(StoryTreeNode currentNode,
//                                 String position,
//                                 String option, String message) {
//        StoryTreeNode newNode =
//        new StoryTreeNode(position, option, message);
//        if (currentNode != null && currentNode.getRightChild()
//        == null) {
//            currentNode.setRightChild
//            (insertToRight(newNode, position, option, message));
//        }
//        return newNode;
//    }

        /*
            When building a tree from file, you should read a line
            and break it in to String tokens using the "|" character as
            the splitting character (you may use String.split() or the
             StringTokenizer class for this purpose). You should then
              construct a new StoryTreeNode using these tokens, and insert
               the node into the tree.

Inserting the node into the tree can be done by parsing the position
 String as a sequence of commands beginning from the root. Remember that
  all position Strings will follow the format "1-2-3- ... ", which
   indicates the sequence of decisions starting from the root. For
   example, the position of the node "1-2-1-3" can be interpreted as:

Begin parsing 'position', setting currentNode = root:
    1 - set currentNode = left child of currentNode.
    2 - set currentNode = middle child of currentNode.
    1 - set currentNode = left child of currentNode.
    3 - insert newNode as right child of currentNode.

             */

    /**
     * Brief:
     * Reads in a text file describing a StoryTree.
     * Preconditions:
     * filename is a non-null, non-empty String that points to a
     * file that exists that is readable, and is valid.
     * @param filename Name of the String file to read from.
     * @return A new StoryTree generated by the passed
     * in text file is returned.
     * @throws DataFormatException Thrown if the file contained data
     * inconsistent with the expected data format
     * @throws FileNotFoundException thrown if the file is not found
     * @throws IllegalArgumentException thrown if filename is empty or null.
     */
    public static StoryTree readTree(String filename)
            throws DataFormatException,
            FileNotFoundException, IllegalArgumentException {
        StoryTree newStoryTree = new StoryTree();
        newStoryTree.resetCursor();
        try {
            if (filename == null || filename.equals("")) {
                throw new IllegalArgumentException();
            }
            File fileName = new File(filename);
            Scanner scanner = new Scanner(fileName);
            String position = "";
            while (scanner.hasNextLine()) {
                String newLine = scanner.nextLine();
//                System.out.print(newLine);
                if (!newLine.contains("1") && !newLine.contains("|")) {
                    throw new DataFormatException();
                }
                position = newLine.split("\\|")[0];
                if (position.length() > 3 && !position.contains("-")) {
                    throw new DataFormatException();
                }
                String option = newLine.split("\\|")[1];
                String message = newLine.split("\\|")[2];
                String[] splitPosition = position.split("-");
                for (int i = 0; i < splitPosition.length; i++) {
//                    System.out.println("Position" + splitPosition.length);
//                    System.out.print("current position" + splitPosition[i]);
                }
                int count = 0;
                newStoryTree.resetCursor();
                while (count < splitPosition.length) {
                    //System.out.print("inside while loop "
                    // + splitPosition.length);
                        int currentPosition = Integer.parseInt
                                (splitPosition[count].trim());
                        if (currentPosition == 1) {
                            if (newStoryTree.getCursor() == null) {
                                break;
                            } else {
                                    if (count == splitPosition.length - 1) {
                                        //System.out.print
                                        // ("count " + count
                                        // + " splitPositionLength: "
                                        // + splitPosition.length);
                                        newStoryTree.getCursor()
                                                .setLeftChild
                                (new StoryTreeNode(position, option, message));
                                    }
                                    newStoryTree
                                            .setCursor
                                    (newStoryTree.getCursor().getLeftChild());
                            }
                        } else if (currentPosition == 2) {
                            if (newStoryTree.getCursor() == null) {
                                break;
                            } else {
                                    if (count == splitPosition.length - 1) {
                                        //System.out.print("count "
                                        // + count + " splitPositionLength: "
                                        // + splitPosition.length);
                                        newStoryTree.getCursor()
                                                .setMiddleChild
                                (new StoryTreeNode(position, option, message));
                                    }
                                    newStoryTree.
                        setCursor(newStoryTree.getCursor().getMiddleChild());
                            }
                        } else if (currentPosition == 3) {
                            if (newStoryTree.getCursor() == null) {
                                break;
                            } else {
                                    if (count == splitPosition.length - 1) {
                                        //System.out.print("count "
                                        // + count
                                        // + " splitPositionLength: "
                                        // + splitPosition.length);
                                        newStoryTree.getCursor()
                                                .setRightChild
                                (new StoryTreeNode(position, option, message));
                                    }
                                    newStoryTree.setCursor(newStoryTree
                                        .getCursor().getRightChild());
                            }
                        }
                    count++;
                    }

                }
                    scanner.close();
                } catch(FileNotFoundException e){
                    System.out.println("The file was not found. " +
                            "This should never occur");
                } catch(IllegalArgumentException e){
                    System.out.println("filename is empty or null. ");
                } catch(DataFormatException e){
                    System.out.println("The file contained data " +
                            "inconsistent with the expected data format.");
                }
                return newStoryTree;
            }

    /**
     * Traverses the tree in preorder
     * @param fileOut Takes in a PrintWriter called fileOut
     * @param root Takes in a StoryTreeNode called root
     */
    public static void preorder(PrintWriter fileOut, StoryTreeNode root) {
        if (root != null){

            fileOut.write(root.getPosition());
            fileOut.write(root.getOption());
            fileOut.write(root.getMessage());
            fileOut.close();
        }
    }

    /**
     * Brief:
     * Saves a StoryTree to the indicated file using
     * the specified data format
     * Preconditions:
     * tree is non-null.
     * filename is a non-null, non-empty String.
     * @param filename Name of the String file to read from.
     * @param tree A reference to the StoryTree tree to save
     *            to the indicated file.
     * @throws IllegalArgumentException Thrown if filename is empty
     * or null or if the tree is null.
     * @throws FileNotFoundException Thrown if the file was not found
     */
    public static void saveTree(String filename, StoryTree tree) throws
            IllegalArgumentException, FileNotFoundException {
        try {
            if (filename == null || filename.equals("")) {
                throw new IllegalArgumentException();
            }
            PrintWriter fileOut = new PrintWriter(filename);
            if (tree == null) {
                throw new IllegalArgumentException();
            } else {
                tree.resetCursor();
                fileOut.write(tree.getCursorPosition());
                fileOut.write(tree.getCursorOption());
                fileOut.write(tree.getCursorMessage());
                while (!tree.getCursor().isLeaf()) {
                    tree.setCursor(tree.getCursor().getLeftChild());
                }
                while (!tree.getCursor().isLeaf()) {
                    tree.setCursor(tree.getCursor().getMiddleChild());
                }
                while (!tree.getCursor().isLeaf()) {
                    tree.setCursor(tree.getCursor().getRightChild());
                    preorder(fileOut, root.getLeftChild());
                    preorder(fileOut, root.getMiddleChild());
                    preorder(fileOut, root.getRightChild());
                }
            }
         //   "save tree to a file"
        } catch (FileNotFoundException e) {
            System.out.println("The file was not found.");
        } catch (IllegalArgumentException e) {
            System.out.println("The filename is empty or null or the " +
                    "tree is null.");
        }
    }

    /**
     * Brief:
     * Gets the current state of the game (state variable).
     * Preconditions:
     * state is not null.
     * @return a GameState called state that is the current state of the
     * game
     */
    public GameState getGameState() {
        if (state != null) {
            return state;
        } else {
            return null;
        }
    }

    /**
     * A getter for the Cursor position
     * @return the string position of the cursor
     */
    public String getCursorPosition() {
        return cursor.getPosition();
    }

    /**
     * A getter for the Cursor message
     * @return the string message of the cursor
     */
    public String getCursorMessage() {
        return cursor.getMessage();
    }

    /**
     * A getter for the Cursor option
     * @return the string option of the cursor
     */
    public String getCursorOption() {
        return cursor.getOption();
    }

    /**
     * Brief:
     * Returns an array of String pairs - {position, option} for
     * each immediate child of the cursor. Do not recurse into those
     * childrens' children.
     * @return a 2d array of String pairs - {position, option}
     */
    public String[][] getOptions() {
        String leftPosition = "";
        String leftOption = "";
        String middlePosition = "";
        String middleOption = "";
        String rightPosition = "";
        String rightOption = "";
        if (cursor.getLeftChild() != null) {
             leftPosition = cursor.getLeftChild().getPosition();
             leftOption = cursor.getLeftChild().getOption();
        }
        if (cursor.getMiddleChild() != null) {
             middlePosition = cursor.getMiddleChild().getPosition();
             middleOption = cursor.getMiddleChild().getOption();
        }
        if (cursor.getRightChild() != null) {
             rightPosition = cursor.getRightChild().getPosition();
             rightOption = cursor.getRightChild().getOption();
        }

        return new String[][]{
            {
                leftPosition, leftOption
            },

            {
                middlePosition, middleOption
            },

            {
                rightPosition, rightOption
            }
        };
    }

    /**
     * A getter for the options of the cursor's children
     * @return the String[] of the children's options
     */
    public String[] getChoices() {
        String leftPosition = "";
        String leftOption = "";
        String middlePosition = "";
        String middleOption = "";
        String rightPosition = "";
        String rightOption = "";
        if (cursor.getLeftChild() != null) {
            // leftPosition = cursor.getLeftChild().getPosition();
            leftOption = cursor.getLeftChild().getOption();
        }
        if (cursor.getMiddleChild() != null) {
            // middlePosition = cursor.getMiddleChild().getPosition();
            middleOption = cursor.getMiddleChild().getOption();
        }
        if (cursor.getRightChild() != null) {
            //rightPosition = cursor.getRightChild().getPosition();
            rightOption = cursor.getRightChild().getOption();
        }

        return new String[]{
                leftOption,
                        middleOption,
                        rightOption
        };
    }

    /**
     * A getter for the cursor
     * @return the StoryTreeNode cursor
     */
    public StoryTreeNode getCursor() {
        return cursor;
    }

    /**
     * A setter for the cursor
     * @param cursor a StoryTreeNode
     */
    public void setCursor(StoryTreeNode cursor) {
        this.cursor = cursor;
    }

    /**
     * A setter for the current cursor's message
     * @param message a String containing the current cursor's message
     */
    public void setCursorMessage(String message) {
        cursor.setMessage(message);
    }

    /**
     * A setter for the current cursor's option
     * @param option a String containing the current cursor's option
     */
    public void setCursorOption(String option) {
        cursor.setOption(option);
    }

    /**
     * A method that resets the cursor to the root
     */
    public void resetCursor() {
        cursor = root;
    }

    /**
     * A method that checks if the children of the cursor are null or not
     * @return the Cursor's children in an int[]
     */
    public int[] getCursorChildrenNumbers() {
        int[] childrenNumbers = new int[3];
        if (cursor.getLeftChild() != null) {
            childrenNumbers[0] += 1;
        }
        if (cursor.getMiddleChild() != null) {
            childrenNumbers[1] += 2;
        }
        if (cursor.getRightChild() != null) {
            childrenNumbers[2] += 3;
        }
        return childrenNumbers;
    }

    /**
     * Brief:
     * Selects the child with the name indicated by position.
     * Preconditions:
     * The child with the indicated position member variable
     * exists as a direct child of the cursor.
     * Postconditions:
     * Cursor references node indicated by position.
     * @param position The position String of the child node to select.
     * @throws InvalidArgumentException Thrown if position is empty or null.
     * @throws NodeNotPresentException Thrown if the node with the indicated
     * position variable was not found.
     */
    public void selectChild(String position) throws InvalidArgumentException,
            NodeNotPresentException  {
        try {
            if (position == null || position.equals("")) {
                throw new InvalidArgumentException();
            }

        String leftPosition = cursor.getLeftChild().getPosition();
        String middlePosition = cursor.getMiddleChild().getPosition();
        String rightPosition = cursor.getRightChild().getPosition();

        if (!position.equals(leftPosition) && !position.equals(middlePosition)
        && !position.equals(rightPosition)) {
            throw new NodeNotPresentException();
        }

        if (position.equals(leftPosition)) {
            cursor = cursor.getLeftChild();
        } else if (position.equals(middlePosition)) {
            cursor = cursor.getMiddleChild();
        } else if (position.equals(rightPosition)) {
            cursor = cursor.getRightChild();
        }

        } catch (InvalidArgumentException e) {
            System.out.println("Position cannot be empty or null.");
        } catch (NodeNotPresentException e) {
            System.out.println("Node with indicated position variable " +
                    "was not found.");
        }
    }

    /**
     * Brief:
     * Adds a new child under the current cursor, with given option
     * and message. I compute the position String in this method.
     * Postconditions:
     * Cursor has new child, with specified message and option.
     * @param option The new String to set as the option of the new child.
     * @param message The new String to set as the message of the new child.
     * @throws InvalidArgumentException Thrown if either String is empty
     * or null.
     * @throws TreeFullException Thrown if all three child spots are
     * already full
     */
    public void addChild(String option, String message) throws
            InvalidArgumentException, TreeFullException {
        try {
            if (option == null || option.equals("")) {
                throw new InvalidArgumentException();
            }
            if (message == null || message.equals("")) {
                throw new InvalidArgumentException();
            }
            StoryTreeNode newNode = new StoryTreeNode();
            if (cursor.getLeftChild() == null) {
                cursor.setLeftChild(newNode);
                cursor.setPosition(cursor.getPosition() + "-1");
                cursor.setOption(option);
                cursor.setMessage(message);
            } else if (cursor.getMiddleChild() == null) {
                cursor.setMiddleChild(newNode);
                cursor.setPosition(cursor.getPosition() + "-2");
                cursor.setOption(option);
                cursor.setMessage(message);
            } else if (cursor.getRightChild() == null) {
                cursor.setRightChild(newNode);
                cursor.setPosition(cursor.getPosition() + "-3");
                cursor.setOption(option);
                cursor.setMessage(message);
            } else {
                throw new TreeFullException();
            }
        } catch (InvalidArgumentException e) {
            System.out.println("Either option or message is empty or null.");
        } catch (TreeFullException e) {
            System.out.println("All three child spots are already full.");
        }
    }

    /**
     * Brief:
     * Removes an immediate child under the current cursor.
     * This method implicitly removes the entire sub-tree for which
     * the indicated child is the root of.
     * Preconditions:
     * The child with the indicated position member variable
     * exists as a direct child of the cursor.
     * Postconditions:
     * The indicated child and it's entire sub-tree have been removed
     * from the tree.
     * @param position String indicating the position of the
     *                child to be removed.
     * @return A StoryTreeNode reference to the child removed (along with its
     * attached sub-tree).
     * @throws NodeNotPresentException Thrown if a node with the
     * indicated position variable was not found.
     */
    public StoryTreeNode removeChild(String position) throws
            NodeNotPresentException {
        StoryTreeNode removed = new StoryTreeNode();

        try {
            String leftPosition = cursor.getLeftChild().getPosition();
            String middlePosition = cursor.getMiddleChild().getPosition();
            String rightPosition = cursor.getRightChild().getPosition();

            if (!position.equals(leftPosition)
                    && !position.equals(middlePosition)
                    && !position.equals(rightPosition)) {
                throw new NodeNotPresentException();
            }

            if (position.equals(rightPosition)) {
                removed = cursor.getRightChild();
                cursor.setRightChild(null);
                cursor = cursor.getMiddleChild();
            } else if (position.equals(middlePosition)) {
                removed = cursor.getMiddleChild();
                cursor.setMiddleChild(null);
                cursor = cursor.getLeftChild();
            } else if (position.equals(leftPosition)) {
                removed = cursor.getLeftChild();
                cursor.setLeftChild(null);
                cursor = root;
            }

        } catch (NodeNotPresentException e) {
            System.out.println("Node with indicated position variable " +
                    "was not found.");
        }
        return removed;
    }
}
//public static void main(String[] args) throws DataFormatException,
// FileNotFoundException {
//    StoryTree tree = StoryTree.readTree("SampleStory.txt");
//    tree.resetCursor();
//    System.out.println("Cursor Position: " + tree.getCursorPosition()
//            + "\nCursor Message: " + tree.getCursorMessage());
//    System.out.println("Cursor Left Position: "
//    + tree.getCursor().getLeftChild().getPosition()
//            + "\nCursor Left Message: "
//            + tree.getCursor().getLeftChild().getMessage());
//
//    System.out.print("Cursor Right Position "
//    + tree.getCursor().getLeftChild().getRightChild().getPosition() +
//            " \nCursor Right Message "
//            + tree.getCursor().getLeftChild().getRightChild().getMessage());
//        }
//}